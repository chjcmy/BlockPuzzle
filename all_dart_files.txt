===== ./test/widget_test.dart =====
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:tetris_app/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}



===== ./lib/utils/route_path.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/theme/component/constrained_screen.dart';
import 'package:tetris_app/view/game/game_view.dart';
import 'package:tetris_app/view/game_over/game_over_view.dart';
import 'package:tetris_app/view/home/home_view.dart';
import 'package:tetris_app/view/leaderboard/leader_board_view.dart';
import 'package:tetris_app/view/login/login_view.dart';

/// RoutePath는 어플리케이션 내의 각 화면으로의 경로를 정의하고,
/// onGenerateRoute 함수를 통해 화면 전환을 담당하는 클래스이옵니다.
abstract class RoutePath {
  static const String login = 'login';
  static const String home = 'home';
  static const String game = 'game';
  static const String gameOver = 'gameOver';
  static const String leaderboard = 'leaderboard';
  static const String settings = 'settings';

  /// onGenerateRoute는 설정된 경로 이름에 따라 적절한 화면 위젯을 반환하사옵니다.
  static Route<dynamic>? onGenerateRoute(RouteSettings settings) {
    late final Widget page;
    switch (settings.name) {
      case RoutePath.login:
        page = const LoginView();
        break;
      case home:
        page = const HomeView();
        break;
      case game:
        page = const GameView();
        break;
      case gameOver:
        final argScore = settings.arguments as int? ?? 0;
        page = GameOverView(lastScore: argScore);
        break;
      case leaderboard:
        page = LeaderboardView();
        break;
    }
    return MaterialPageRoute(
      builder: (context) => ConstrainedScreen(child: page),
    );
  }
}



===== ./lib/utils/helper/net_helper.dart =====
import 'dart:developer';

import 'package:dio/dio.dart';

abstract class NetworkHelper {
  static final Dio dio =
      Dio()
        ..interceptors.add(
          InterceptorsWrapper(
            onRequest: (options, handler) {
              log('REQ : [${options.method} ${options.path}]');
              return handler.next(options);
            },
            onResponse: (response, handler) {
              log(
                'RES : [${response.statusCode}] ${response.requestOptions.path}',
              );
              return handler.next(response);
            },
            onError: (DioException e, handler) {
              log('ERR : [${e.response?.statusCode}] ${e.requestOptions.path}');
              return handler.next(e);
            },
          ),
        );
}



===== ./lib/utils/helper/immutable_helper.dart =====



===== ./lib/utils/helper/intl_helper.dart =====



===== ./lib/repositories/user_repository.dart =====
import 'package:shared_preferences/shared_preferences.dart';

class UserRepository {
  Future<void> saveUserId(String userId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('userId', userId);
  }

  Future<String?> loadUserId() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('userId');
  }
}



===== ./lib/repositories/score_repository.dart =====
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:tetris_app/models/score.dart';


class ScoreRepository {
  Database? _db;

  /// DB 초기화 및 테이블 생성
  Future<void> init() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'scores.db');

    _db = await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) async {
        await db.execute('''
          CREATE TABLE scores(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            score INTEGER,
            dateTime TEXT
          )
        ''');
      },
    );
  }

  /// 점수 기록 추가
  Future<int> addScore(Score score) async {
    if (_db == null) await init();
    return await _db!.insert('scores', score.toMap());
  }

  /// 모든 점수 기록 불러오기 (최신순)
  Future<List<Score>> getAllScores() async {
    if (_db == null) await init();
    final List<Map<String, dynamic>> result =
        await _db!.query('scores', orderBy: 'dateTime DESC');
    return result.map((map) => Score.fromMap(map)).toList();
  }

  /// 점수 기록 삭제 (선택사항)
  Future<int> deleteScore(int id) async {
    if (_db == null) await init();
    return await _db!.delete(
      'scores',
      where: 'id = ?',
      whereArgs: [id],
    );
  }
}


===== ./lib/repositories/leaderboard_repository.dart =====
// leaderboard_repository.dart
import 'dart:convert';
import 'dart:developer';

import 'package:dio/dio.dart';
import 'package:tetris_app/models/leaderboard_entry.dart';
import 'package:tetris_app/utils/helper/net_helper.dart';

class LeaderboardRepository {
  // 기본 베이스 URL: localhost:3000
  static const String baseUrl = "http://1.232.205.46:3000";
  // dio 인스턴스 (NetworkHelper.dio를 사용한다고 가정)
  final Dio dio = NetworkHelper.dio;

  /// GET /scores?keyword=...&skip=...&take=...
  /// keyword가 주어지면 해당 키워드를 포함한 Score 데이터를 조회하고,
  /// 페이지 번호(page)와 한 페이지 당 항목 수(pageSize)를 적용하여
  /// LeaderboardEntry 리스트를 반환합니다.
  Future<List<LeaderboardEntry>> getLeaderboardEntries({
    String? keyword,
    int page = 1,
    int pageSize = 10,
  }) async {
    // 페이지 번호는 1부터 시작하므로 skip 계산: (page - 1) * pageSize
    final int skip = (page - 1) * pageSize;
    final int take = pageSize;

    // URL 구성: 검색어와 페이징 정보 추가
    String url = "$baseUrl/scores";
    if (keyword != null && keyword.isNotEmpty) {
      url += "?keyword=$keyword&skip=$skip&take=$take";
    } else {
      url += "?skip=$skip&take=$take";
    }

    try {
      final res = await dio.get(url);

      // 응답 데이터 타입에 따라 처리
      final List<dynamic> data;
      if (res.data is String) {
        data = jsonDecode(res.data);
      } else if (res.data is List) {
        data = res.data;
      } else {
        throw Exception(
          "Unexpected response data type: ${res.data.runtimeType}",
        );
      }

      // 각 JSON Map을 LeaderboardEntry 객체로 변환합니다.
      final entries =
          data.map<LeaderboardEntry>((json) {
            return LeaderboardEntry.fromJson(json);
          }).toList();

      // 페이지 기반 순위 재설정 (전체 데이터 기준 순위)
      for (int i = 0; i < entries.length; i++) {
        entries[i] = LeaderboardEntry(
          rank: skip + i + 1,
          name: entries[i].name,
          score: entries[i].score,
        );
      }
      return entries;
    } catch (e, stack) {
      log("getLeaderboardEntries 에러: $e");
      log("$stack");
      return [];
    }
  }

  /// POST /scores
  /// 주어진 Score 데이터를 서버로 전송합니다.
  Future<bool> postScore(Map<String, dynamic> scoreData) async {
    final url = "$baseUrl/scores";
    try {
      final response = await dio.post(
        url,
        data: scoreData,
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode != null &&
          response.statusCode! >= 200 &&
          response.statusCode! < 300) {
        log("POST 성공: ${response.data}");
        return true;
      } else {
        log(
          "POST 실패: statusCode=${response.statusCode}, response=${response.data}",
        );
        return false;
      }
    } catch (e, stack) {
      log("POST 에러: $e");
      log("$stack");
      return false;
    }
  }
}



===== ./lib/models/score_type.dart =====
enum ScoreSortType {
  highScore, // 높은 점수순 정렬
  latest,    // 최신순 정렬
}


===== ./lib/models/leaderboard_entry.dart =====
import 'package:equatable/equatable.dart';

/// 리더보드에 표시할 한 명의 데이터 (랭킹, 플레이어 ID, 점수)
class LeaderboardEntry extends Equatable {
  final int rank;
  final String name;
  final int score;

  const LeaderboardEntry({
    required this.rank,
    required this.name,
    required this.score,
  });

  @override
  List<Object?> get props => [rank, name, score];

  // fromJson 생성자: JSON Map으로부터 LeaderboardEntry 객체를 생성합니다.
  factory LeaderboardEntry.fromJson(Map<String, dynamic> json) {
    return LeaderboardEntry(
      rank: json['rank'] as int? ?? 0, // 만약 서버에서 rank 정보가 없다면 기본 0
      name: json['name'] as String? ?? 'unknown',
      score: json['score'] as int? ?? 0,
    );
  }
}



===== ./lib/models/user.dart =====
import 'package:equatable/equatable.dart';

/// User 클래스는 간단한 사용자 정보를 관리하기 위한 모델로, Equatable을 상속받아 값 비교가 용이하사옵니다.
class User extends Equatable {
  final String id;
  final String username;
  final String? avatarUrl;

  const User({required this.id, required this.username, this.avatarUrl});

  /// 선택적 속성 변경을 위한 복사 생성자
  User copyWith({String? id, String? username, String? avatarUrl}) {
    return User(
      id: id ?? this.id,
      username: username ?? this.username,
      avatarUrl: avatarUrl ?? this.avatarUrl,
    );
  }

  @override
  List<Object?> get props => [id, username, avatarUrl];
}



===== ./lib/models/score.dart =====
import 'package:equatable/equatable.dart';

class Score extends Equatable {

  final int score;
  final DateTime dateTime;

  const Score({
    required this.score,
    required this.dateTime,
  });

  /// DB 저장/조회 시 Map 변환
  Map<String, dynamic> toMap() {
    return {
      'score': score,
      'dateTime': dateTime.toIso8601String(),
    };
  }

  /// DB에서 가져온 Map 데이터를 Score 객체로 변환
  factory Score.fromMap(Map<String, dynamic> map) {
    return Score(
      score: map['score'] as int,
      dateTime: DateTime.parse(map['dateTime'] as String),
    );
  }

  @override
  List<Object?> get props => [score, dateTime];
}



===== ./lib/models/tetrimino/piece_type.dart =====
/// piece.dart
/// 테트리스 조각(PieceType)과 조각의 모양(상대 좌표)을 정의하는 파일입니다.
/// rotation(0~3)에 따라 각 조각의 상대적 형태를 제공하는 함수를 구현하여,
/// BLoC 혹은 ViewModel에서 활용할 수 있도록 합니다.
library;

import 'package:tetris_app/models/tetrimino/position.dart';

/// 테트리스 조각 유형을 열거형으로 정의합니다.
enum PieceType { I, O, T, S, Z, J, L }

/// 주어진 조각 유형(pieceType)과 회전 상태(rotation)에 따라
/// 상대 좌표를 반환합니다.
///
/// rotation은 0~3 범위를 가지며, 0은 기본 상태,
/// 1~3은 시계 방향으로 90도씩 회전한 상태를 의미합니다.
///
/// 반환되는 리스트는 각 블록의 상대 좌표(0,0)을 기준으로
/// (x, y) 형태로 구성됩니다.
List<Position> getTetriminoShape(PieceType pieceType, int rotation) {
  // 각 조각마다 rotation(0~3)에 따른 상대 좌표를 정의합니다.
  // (0,0)을 기준으로 위쪽/오른쪽 방향으로 좌표계를 잡았다고 가정
  // 테트리스에서는 y가 위->아래 증가 방향이므로, 필요 시 y 축을 반전할 수도 있음.
  switch (pieceType) {
    case PieceType.I:
      // I 모양 (4칸 일자)
      // rotation: 0 => 수평, 1 => 수직 (이하 반복)
      switch (rotation % 4) {
        case 0: // 가로 방향
          return [
            Position(0, 0),
            Position(1, 0),
            Position(2, 0),
            Position(3, 0),
          ];
        case 1: // 세로 방향
          return [
            Position(0, 0),
            Position(0, 1),
            Position(0, 2),
            Position(0, 3),
          ];
        case 2: // 가로 방향 (뒤집힘)
          return [
            Position(0, 0),
            Position(1, 0),
            Position(2, 0),
            Position(3, 0),
          ];
        case 3: // 세로 방향 (반대)
          return [
            Position(0, 0),
            Position(0, 1),
            Position(0, 2),
            Position(0, 3),
          ];
      }

    case PieceType.O:
      // O 모양 (정사각형 2x2)
      // 회전해도 동일
      return [Position(0, 0), Position(1, 0), Position(0, 1), Position(1, 1)];

    case PieceType.T:
      switch (rotation % 4) {
        case 0:
          return [
            Position(0, 0),
            Position(1, 0),
            Position(2, 0),
            Position(1, 1),
          ];
        case 1:
          return [
            Position(0, 1),
            Position(0, 0),
            Position(0, 2),
            Position(1, 1),
          ];
        case 2:
          return [
            Position(0, 1),
            Position(1, 1),
            Position(2, 1),
            Position(1, 0),
          ];
        case 3:
          return [
            Position(1, 0),
            Position(1, 1),
            Position(1, 2),
            Position(0, 1),
          ];
      }

    case PieceType.S:
      switch (rotation % 4) {
        case 0:
        case 2:
          return [
            Position(1, 0),
            Position(2, 0),
            Position(0, 1),
            Position(1, 1),
          ];
        case 1:
        case 3:
          return [
            Position(0, 0),
            Position(0, 1),
            Position(1, 1),
            Position(1, 2),
          ];
      }

    case PieceType.Z:
      switch (rotation % 4) {
        case 0:
        case 2:
          return [
            Position(0, 0),
            Position(1, 0),
            Position(1, 1),
            Position(2, 1),
          ];
        case 1:
        case 3:
          return [
            Position(1, 0),
            Position(0, 1),
            Position(1, 1),
            Position(0, 2),
          ];
      }

    case PieceType.J:
      switch (rotation % 4) {
        case 0:
          return [
            Position(0, 0),
            Position(0, 1),
            Position(1, 0),
            Position(2, 0),
          ];
        case 1:
          return [
            Position(0, 0),
            Position(0, 1),
            Position(0, 2),
            Position(1, 0),
          ];
        case 2:
          return [
            Position(0, 1),
            Position(1, 1),
            Position(2, 1),
            Position(2, 0),
          ];
        case 3:
          return [
            Position(0, 2),
            Position(1, 2),
            Position(1, 1),
            Position(1, 0),
          ];
      }

    case PieceType.L:
      switch (rotation % 4) {
        case 0:
          return [
            Position(2, 0),
            Position(0, 0),
            Position(1, 0),
            Position(2, 1),
          ];
        case 1:
          return [
            Position(0, 0),
            Position(0, 1),
            Position(0, 2),
            Position(1, 2),
          ];
        case 2:
          return [
            Position(0, 0),
            Position(0, 1),
            Position(1, 1),
            Position(2, 1),
          ];
        case 3:
          return [
            Position(0, 0),
            Position(1, 0),
            Position(1, 1),
            Position(1, 2),
          ];
      }
  }
  // 만약 모든 케이스가 처리되지 않았다면 예외 발생
  throw UnimplementedError(
    'Unhandled pieceType: $pieceType, rotation: $rotation',
  );
}



===== ./lib/models/tetrimino/position.dart =====
import 'package:equatable/equatable.dart';

class Position extends Equatable {
  final int x;
  final int y;
  const Position(this.x, this.y);

  @override
  List<Object?> get props => [x, y];
}



===== ./lib/models/tetrimino/direction.dart =====
/// 테트리미노 조각의 이동 방향을 정의합니다.
enum Direction {
  left,  // 왼쪽 방향
  right, // 오른쪽 방향
  down,  // 아래 방향
}


===== ./lib/main.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:tetris_app/repositories/leaderboard_repository.dart';
import 'package:tetris_app/repositories/score_repository.dart';
import 'package:tetris_app/repositories/user_repository.dart';
import 'package:tetris_app/service/theme/theme_service.dart';
import 'package:tetris_app/utils/route_path.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final initialRoute = await getInitialRoute();
  final leaderboardRepository = LeaderboardRepository();
  final scoreRepo = ScoreRepository();
  await scoreRepo.init();

  runApp(
    MultiRepositoryProvider(
      providers: [
        RepositoryProvider(create: (context) => scoreRepo),
        RepositoryProvider(create: (context) =>  UserRepository()),
        RepositoryProvider(create: (context) => leaderboardRepository),
      ],
      child: MultiBlocProvider(
        providers: [
          BlocProvider<ThemeService>(create: (context) => ThemeService()),
        ],
        child: MyApp(initialRoute: initialRoute),
      ),
    ),
  );
}

Future<String> getInitialRoute() async {
  final prefs = await SharedPreferences.getInstance();
  final storedUserId = prefs.getString('userId');
  if (storedUserId != null && storedUserId.trim().isNotEmpty) {
    return RoutePath.home;
  }
  return RoutePath.login;
}

class MyApp extends StatelessWidget {
  const MyApp({super.key, required this.initialRoute});
  final String initialRoute;

  static final GlobalKey<NavigatorState> navigatorKey = GlobalKey();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      debugShowCheckedModeBanner: false,
      builder:
          (context, child) => Overlay(
            initialEntries: [OverlayEntry(builder: (context) => child!)],
          ),
      theme: context.themeService.themeData,
      initialRoute: initialRoute,
      onGenerateRoute: RoutePath.onGenerateRoute,
    );
  }
}



===== ./lib/theme/light_theme.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/theme/foundation/app_theme.dart';
import 'package:tetris_app/theme/foundation/app_typo.dart';
import 'package:tetris_app/theme/res/palette.dart';
import 'package:tetris_app/theme/res/typo.dart';


class LightTetrisTheme implements AppTheme {
  @override
  Brightness brightness = Brightness.light;

  @override
  AppColor color = const AppColor(
    surface: Palette.greyLight,             // 카드, 위젯 표면 색상
    background: Palette.backgroundLight,      // 전체 배경색 (흰색)
    text: Palette.textLight,                  // 기본 텍스트 색상 (검정)
    subtext: Palette.greyMedium,              // 보조 텍스트 색상
    primary: Palette.primary,                 // 주요 색상 (녹색 계열)
    onPrimary: Palette.white,                 // 주요 색상 위 텍스트 색상
    secondary: Palette.secondary,             // 보조 색상 (붉은색 계열)
    onSecondary: Palette.white,               // 보조 색상 위 텍스트 색상
    tertiary: Palette.accent,                 // 강조 색상 (노란색 계열)
    onTertiary: Palette.black,                // 강조 색상 위 텍스트 색상
  );

  @override
  AppDeco deco = const AppDeco(
    shadows: [
      BoxShadow(
        color: Colors.black12,
        blurRadius: 10,
        offset: Offset(0, 5),
      ),
    ],
    borderRadius: BorderRadius.all(Radius.circular(8.0)),
  );

  @override
  AppTypo typo = AppTypo(
    typo: NotoSansTypo(),
    fontColor: Palette.textLight,
  );
}


===== ./lib/theme/res/typo.dart =====
import 'package:flutter/material.dart';

/// 앱 전반에서 사용할 폰트 정보와 폰트 굵기를 정의한 추상 클래스
abstract class Typo {
  String get fontFamily;
  FontWeight get light;
  FontWeight get regular;
  FontWeight get semiBold;
  FontWeight get bold;
}

/// Tetris 어플에 적합한 NotoSans 폰트를 사용하는 Typo 구현체
class NotoSansTypo implements Typo {
  @override
  final String fontFamily = 'NotoSans';  // Noto Sans 폰트 (프로젝트에 포함 필요)

  @override
  final FontWeight light = FontWeight.w300;

  @override
  final FontWeight regular = FontWeight.w400;

  @override
  final FontWeight semiBold = FontWeight.w600;

  @override
  final FontWeight bold = FontWeight.w700;
}


===== ./lib/theme/res/palette.dart =====
import 'package:flutter/material.dart';

/// Tetris 어플리케이션에서 사용할 색상 팔레트
abstract class Palette {
  // 주요 색상 계열
  static const Color primary = Color(0xFF5AC463);   // 녹색 계열
  static const Color secondary = Color(0xFFFB432F); // 붉은색 계열
  static const Color accent = Color(0xFFFEC85B);    // 노란색 계열

  // 기본 배경 및 텍스트 색상
  static const Color white = Colors.white;
  static const Color black = Colors.black;

  // 배경 색상 (라이트/다크)
  static const Color backgroundLight = Colors.white;
  static const Color backgroundDark = Colors.black;

  // 텍스트 색상 (라이트/다크)
  static const Color textLight = Colors.black;
  static const Color textDark = Colors.white;

  // 추가적인 무채색 계열
  static const Color greyLight = Color(0xFFFAFAFA);
  static const Color greyMedium = Color(0xFFB7B7B7);
  static const Color greyDark = Color(0xFF111111);
}


===== ./lib/theme/foundation/app_theme.dart =====
import 'package:flutter/material.dart';

import 'app_typo.dart';
part 'app_color.dart';
part 'app_deco.dart';


/// 앱 전반의 테마 정보를 추상화한 클래스
abstract class AppTheme {
  late final Brightness brightness;
  late final AppColor color;
  late final AppDeco deco;
  late final AppTypo typo;
}


===== ./lib/theme/foundation/app_typo.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/theme/res/typo.dart';

class AppTypo {
  final Typo typo;
  final Color fontColor;

  AppTypo({required this.typo, required this.fontColor});

  /// 게임 타이틀, 중요한 정보에 사용 (예: 'GAME OVER' 또는 점수)
  TextStyle get headline1 => TextStyle(
    fontFamily: typo.fontFamily,
    fontSize: 36,
    fontWeight: typo.bold,
    color: fontColor,
  );

  /// 서브 타이틀이나 강조 텍스트에 사용
  TextStyle get headline2 => TextStyle(
    fontFamily: typo.fontFamily,
    fontSize: 28,
    fontWeight: typo.semiBold,
    color: fontColor,
  );

  /// 일반 본문 텍스트 스타일 (예: 게임 설명, 메뉴 텍스트)
  TextStyle get bodyText1 => TextStyle(
    fontFamily: typo.fontFamily,
    fontSize: 16,
    fontWeight: typo.regular,
    color: fontColor,
  );

  /// 보조 텍스트 스타일 (예: 캡션, 날짜, 소제목)
  TextStyle get caption => TextStyle(
    fontFamily: typo.fontFamily,
    fontSize: 12,
    fontWeight: typo.light,
  );

  /// 버튼 텍스트 스타일
  TextStyle get button => TextStyle(
    fontFamily: typo.fontFamily,
    fontSize: 16,
    fontWeight: typo.semiBold,
    color: fontColor,
  );
}



===== ./lib/theme/foundation/app_color.dart =====
part of 'app_theme.dart';

/// Tetris 어플리케이션 전용 색상 팔레트
class AppColor {
  /// 카드나 위젯 표면 배경 색상
  final Color surface;

  /// 전체 배경 색상
  final Color background;

  /// 기본 텍스트 색상
  final Color text;

  /// 보조 텍스트 색상
  final Color subtext;

  /// 주요 색상 (버튼, 헤더 등 강조 요소)
  final Color primary;

  /// 주요 색상 위의 텍스트/아이콘 색상
  final Color onPrimary;

  /// 보조 색상
  final Color secondary;

  /// 보조 색상 위의 텍스트/아이콘 색상
  final Color onSecondary;

  /// 추가 강조 색상
  final Color tertiary;

  /// 추가 강조 색상 위의 텍스트/아이콘 색상
  final Color onTertiary;

  const AppColor({
    required this.surface,
    required this.background,
    required this.text,
    required this.subtext,
    required this.primary,
    required this.onPrimary,
    required this.secondary,
    required this.onSecondary,
    required this.tertiary,
    required this.onTertiary,
  });
}


===== ./lib/theme/foundation/app_deco.dart =====
part of 'app_theme.dart';

/// 앱 전반에 적용할 데코레이션(그림자, 모서리 둥글기 등)을 관리하는 클래스
class AppDeco {
  /// 위젯에 적용할 그림자 효과 리스트
  final List<BoxShadow> shadows;

  /// 위젯의 기본 모서리 둥글기
  final BorderRadius borderRadius;

  const AppDeco({
    this.shadows = const [],
    this.borderRadius = BorderRadius.zero,
  });
}


===== ./lib/theme/component/bottom_bar/base_bottom_bar.dart =====
import 'package:flutter/material.dart';

class BaseBottomBar extends StatelessWidget {
  final int currentIndex;
  final ValueChanged<int> onTap;
  final List<BottomNavigationBarItem>? items;

  const BaseBottomBar({
    super.key,
    required this.currentIndex,
    required this.onTap,
    this.items,
  });

  List<BottomNavigationBarItem> _buildItems(BuildContext context) {
    return items ??
        [
          const BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: '홈',
          ),
          const BottomNavigationBarItem(
            icon: Icon(Icons.videogame_asset),
            label: '게임 시작',
          ),
          const BottomNavigationBarItem(
            icon: Icon(Icons.leaderboard),
            label: '전체 순위',
          ),
        ];
  }

  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      currentIndex: currentIndex,
      onTap: onTap,
      items: _buildItems(context),
    );
  }
}


===== ./lib/theme/component/constrained_screen.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/service/theme/theme_service.dart';

class ConstrainedScreen extends StatelessWidget {

  const ConstrainedScreen({
    super.key,
    required this.child,
  });

  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Container(
      // 자식 위젯을 중앙에 정렬한다
      alignment: Alignment.center,
      color: context.color.surface,
      child: ConstrainedBox(
        // 자식 위젯의 크기를 제약한다
        constraints: const BoxConstraints(),
        // 제한된 크기 내에서 전달 받은 자식 위젯을 표시 한다.
        child: child,
      ),
    );
  }
}


===== ./lib/theme/component/circular_indicator.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/service/theme/theme_service.dart';

class CircularIndicator extends StatelessWidget {
  const CircularIndicator({
    super.key,
    required this.child,
    required this.isBusy,
  });

  final Widget child;
  final bool isBusy;

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        IgnorePointer(
          // 터치 이벤트 차단
          ignoring: !isBusy,
          child: AnimatedOpacity(
            // 투명도 활용
            opacity: isBusy ? 1 : 0,

            duration: const Duration(milliseconds: 222),
            child: Container(
              color: context.color.background,
              alignment: Alignment.center,
              child: CircularProgressIndicator(
                color: context.color.primary,
                value: isBusy ? null : 0,
              ),
            ),
          ),
        )
      ],
    );
  }
}



===== ./lib/theme/dark_theme.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/theme/foundation/app_theme.dart';
import 'package:tetris_app/theme/foundation/app_typo.dart';
import 'package:tetris_app/theme/res/palette.dart';
import 'package:tetris_app/theme/res/typo.dart';


class DarkTetrisTheme implements AppTheme {
  @override
  Brightness brightness = Brightness.dark;

  @override
  AppColor color = const AppColor(
    surface: Palette.greyDark,                // 어두운 계열의 표면 색상
    background: Palette.backgroundDark,         // 전체 배경색 (검정)
    text: Palette.textDark,                     // 기본 텍스트 색상 (흰색)
    subtext: Palette.greyMedium,                // 보조 텍스트 색상 (적당한 명도)
    primary: Palette.primary,                   // 주요 색상 (녹색 계열)
    onPrimary: Palette.black,                   // 주요 색상 위 텍스트 색상 (어두운 색)
    secondary: Palette.secondary,               // 보조 색상 (붉은색 계열)
    onSecondary: Palette.black,                 // 보조 색상 위 텍스트 색상 (어두운 색)
    tertiary: Palette.accent,                   // 강조 색상 (노란색 계열)
    onTertiary: Palette.white,                  // 강조 색상 위 텍스트 색상 (흰색)
  );

  @override
  AppDeco deco = const AppDeco(
    shadows: [
      BoxShadow(
        color: Colors.black54,
        blurRadius: 10,
        offset: Offset(0, 5),
      ),
    ],
    borderRadius: BorderRadius.all(Radius.circular(8.0)),
  );

  @override
  AppTypo typo = AppTypo(
    typo: NotoSansTypo(),
    fontColor: Palette.textDark,
  );
}


===== ./lib/view/home/home_view_event.dart =====
// home_view_event.dart
part of 'home_view_model.dart';

abstract class HomeViewEvent extends Equatable {
  const HomeViewEvent();

  @override
  List<Object?> get props => [];
}

/// 점수 목록을 로드하라는 이벤트
class LoadScoreList extends HomeViewEvent {
  const LoadScoreList();
}

/// 점수 목록의 정렬 방식을 변경하라는 이벤트
class SortScoreList extends HomeViewEvent {
  final ScoreSortType sortType;
  const SortScoreList(this.sortType);

  @override
  List<Object?> get props => [sortType];
}



===== ./lib/view/home/home_view.dart =====
// home_view.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/models/score.dart';
import 'package:tetris_app/models/score_type.dart';
import 'package:tetris_app/view/base_view.dart'; // BaseView import
import 'package:tetris_app/view/home/home_view_model.dart'; // BLoC(ViewModel)
import 'package:tetris_app/view/home/widget/home_bottom_bar.dart';
import 'package:tetris_app/view/home/widget/home_toggle_button.dart';

class HomeView extends StatelessWidget {
  const HomeView({super.key});

  @override
  Widget build(BuildContext context) {
    late final HomeViewModel homeViewModel = HomeViewModel(
      scoreRepository: context.read(),
    )..add(const LoadScoreList());

    // BaseView를 사용하여 HomeViewModel을 제공 + builder로 UI 구성
    return BaseView(
      // BLoC 인스턴스 생성 + 초기 이벤트 전달
      viewModel: homeViewModel,
      builder: (context, viewModel) {
        return Scaffold(
          appBar: AppBar(title: const Text('Home')),
          bottomNavigationBar: const HomeBottomBar(),
          body: _buildBody(context, viewModel),
        );
      },
    );
  }

  // 화면의 메인 영역을 빌드
  Widget _buildBody(BuildContext context, HomeViewModel viewModel) {
    // 에러가 있으면 에러 표시
    if (viewModel.state.error != null) {
      return Center(child: Text('오류: ${viewModel.state.error}'));
    }
    // 데이터가 없으면 "등록된 점수가 없습니다." 표시
    if (viewModel.state.scoreList.isEmpty) {
      return const Center(child: Text('등록된 점수가 없습니다.'));
    }

    // 최고 점수 계산
    final bestScore = _getBestScore(viewModel.state.scoreList);

    return Column(
      children: [
        // "나의 최고 기록" 텍스트
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 16),
          child: Text(
            bestScore != null
                ? '나의 최고 기록: ${bestScore.score}점'
                : '나의 최고 기록: 없음',
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ),

        // 정렬 버튼 행
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ToggleButton(
              isSelected: viewModel.state.sortType == ScoreSortType.highScore,
              label: '높은 점수순',
              onPressed: () {
                viewModel.add(const SortScoreList(ScoreSortType.highScore));
              },
            ),
            const SizedBox(width: 8),
            ToggleButton(
              isSelected: viewModel.state.sortType == ScoreSortType.latest,
              label: '최신순',
              onPressed: () {
                viewModel.add(const SortScoreList(ScoreSortType.latest));
              },
            ),
          ],
        ),
        const SizedBox(height: 16),

        // 점수 목록
        Expanded(
          child: ListView.builder(
            itemCount: viewModel.state.scoreList.length,
            itemBuilder: (context, index) {
              final score = viewModel.state.scoreList[index];
              return ListTile(
                leading: const Icon(Icons.star),
                title: Text('${score.score}점'),
                subtitle: Text(score.dateTime.toString()),
              );
            },
          ),
        ),
      ],
    );
  }

  // 최고 점수 계산
  Score? _getBestScore(List<Score> scores) {
    if (scores.isEmpty) return null;
    return scores.reduce((a, b) => a.score > b.score ? a : b);
  }
}


===== ./lib/view/home/widget/home_toggle_button.dart =====
import 'package:flutter/material.dart';

/// 단일 토글 버튼. [isSelected]가 true이면 검정 배경에 흰색 글자,
/// false이면 흰색 배경에 검정 글자와 검정 테두리를 표시
class ToggleButton extends StatelessWidget {
  final bool isSelected;
  final String label;
  final VoidCallback onPressed;

  const ToggleButton({
    Key? key,
    required this.isSelected,
    required this.label,
    required this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialButton(
      onPressed: onPressed,
      color: isSelected ? Colors.black : Colors.white,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: BorderSide(
          color: Colors.black,
          width: 1,
        ),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: isSelected ? Colors.white : Colors.black,
        ),
      ),
      minWidth: 100,
      height: 40,
      // 위/아래, 좌/우 여백 등을 조정하고 싶다면 padding 설정 가능
      // padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    );
  }
}


===== ./lib/view/home/widget/home_bottom_bar.dart =====
import 'package:flutter/material.dart';
import 'package:tetris_app/theme/component/bottom_bar/base_bottom_bar.dart';
import 'package:tetris_app/utils/route_path.dart';

class HomeBottomBar extends StatelessWidget {
  const HomeBottomBar({super.key});

  @override
  Widget build(BuildContext context) {
    return BaseBottomBar(
      currentIndex: 0,
      onTap: (index) {
        switch (index) {
          case 0:
            // 홈 화면
            Navigator.pushNamed(context, RoutePath.home);
            break;
          case 1:
            Navigator.pushNamed(context, RoutePath.game);
            break;
          case 2:
            Navigator.pushNamed(context, RoutePath.leaderboard);
            break;
        }
      },
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.dashboard), // 여기서 변경
          label: '홈',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.videogame_asset),
          label: '게임 시작',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.leaderboard),
          label: '전체 순위',
        ),
      ],
    );
  }
}


===== ./lib/view/home/home_view_state.dart =====
part of 'home_view_model.dart';

/// 홈 화면 상태
class HomeViewState extends BaseViewState with EquatableMixin {
  /// 점수 목록
  final List<Score> scoreList;
  /// 로딩 중인지 여부
  final bool isLoading;
  /// 현재 정렬 방식
  final ScoreSortType sortType;
  /// 에러 메시지 (있을 경우)
  final String? error;

  const HomeViewState({
    required super.isBusy,
    this.scoreList = const [],
    this.isLoading = false,
    this.sortType = ScoreSortType.latest,
    this.error,
  });

  HomeViewState copyWith({
    List<Score>? scoreList,
    bool? isLoading,
    ScoreSortType? sortType,
    String? error,
    bool? isBusy,
  }) {
    return HomeViewState(
      isBusy: isBusy ?? this.isBusy,
      scoreList: scoreList ?? this.scoreList,
      isLoading: isLoading ?? this.isLoading,
      sortType: sortType ?? this.sortType,
      error: error,
    );
  }

  @override
  List<Object?> get props => [isBusy, scoreList, isLoading, sortType, error];
}


===== ./lib/view/home/home_view_model.dart =====
// home_view_model.dart
import 'dart:developer';

import 'package:equatable/equatable.dart';
import 'package:tetris_app/models/score.dart';
import 'package:tetris_app/models/score_type.dart';
import 'package:tetris_app/repositories/score_repository.dart';
import 'package:tetris_app/view/base_view_model.dart';
import 'package:tetris_app/view/base_view_state.dart';

part 'home_view_event.dart';
part 'home_view_state.dart';

class HomeViewModel extends BaseViewModel<HomeViewEvent, HomeViewState> {
  final ScoreRepository scoreRepository;

  HomeViewModel({required this.scoreRepository})
      : super(HomeViewState(
          isBusy: false,
          scoreList: const [],
          sortType: ScoreSortType.latest,
          error: null,
        )) {
    // 이벤트 핸들러 등록: 점수 목록 로드
    on<LoadScoreList>((event, emit) async {
      emit(state.copyWith(isBusy: true, error: null));
      try {
        final scores = await scoreRepository.getAllScores();
        log('✅ Loaded scores: $scores');
        emit(state.copyWith(isBusy: false, scoreList: scores));
      } catch (e) {
        emit(state.copyWith(isBusy: false, error: e.toString()));
      }
    });

    // 이벤트 핸들러 등록: 점수 목록 정렬
    on<SortScoreList>((event, emit) async {
      final currentList = List<Score>.from(state.scoreList);
      if (event.sortType == ScoreSortType.highScore) {
        currentList.sort((a, b) => b.score.compareTo(a.score));
      } else {
        currentList.sort((a, b) => b.dateTime.compareTo(a.dateTime));
      }
      emit(state.copyWith(scoreList: currentList, sortType: event.sortType));
    });
  }
}


===== ./lib/view/base_view_model.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/view/base_view_state.dart';

class BaseViewModel<E, S extends BaseViewState> extends Bloc<E, S> {
  BaseViewModel(super.initialState);
}


===== ./lib/view/base_view_state.dart =====
class BaseViewState {

  const BaseViewState({
    required this.isBusy,
  });

  final bool isBusy;
}



===== ./lib/view/leaderboard/leader_board_view_state.dart =====
part of 'leader_board_view_model.dart';

class LeaderboardState extends BaseViewState with EquatableMixin {
  /// 리더보드 목록
  final List<LeaderboardEntry> entries;

  /// 검색 키워드
  final String keyword;

  /// 에러 메시지 (null이면 에러 없음)
  final String? error;

  /// 현재 페이지 번호
  final int currentPage;

  const LeaderboardState({
    required super.isBusy,
    required this.entries,
    required this.keyword,
    required this.error,
    required this.currentPage,
  });

  factory LeaderboardState.initial() {
    return const LeaderboardState(
      isBusy: false,
      entries: [],
      keyword: '',
      error: null,
      currentPage: 1,
    );
  }

  LeaderboardState copyWith({
    bool? isBusy,
    List<LeaderboardEntry>? entries,
    String? keyword,
    String? error,
    int? currentPage,
  }) {
    return LeaderboardState(
      isBusy: isBusy ?? this.isBusy,
      entries: entries ?? this.entries,
      keyword: keyword ?? this.keyword,
      error: error,
      currentPage: currentPage ?? this.currentPage,
    );
  }

  @override
  List<Object?> get props => [isBusy, entries, keyword, error, currentPage];
}



===== ./lib/view/leaderboard/leader_board_view_model.dart =====
import 'dart:developer';

import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/models/leaderboard_entry.dart';
import 'package:tetris_app/repositories/leaderboard_repository.dart';
import 'package:tetris_app/view/base_view_model.dart';
import 'package:tetris_app/view/base_view_state.dart';

part 'leader_board_view_event.dart';
part 'leader_board_view_state.dart';

class LeaderboardViewModel
    extends BaseViewModel<LeaderboardEvent, LeaderboardState> {
  // 페이지 사이즈 (한 번에 불러올 아이템 수)
  static const int _pageSize = 20;
  // 현재 페이지 번호 (초기값 1)
  final LeaderboardRepository repository;

  LeaderboardViewModel({required this.repository})
    : super(LeaderboardState.initial()) {
    on<LeaderboardLoadRequested>(_onLoadRequested);
    on<LeaderboardSearchChanged>(_onSearchChanged);
    on<LoadMoreLeaderboard>(_onLoadMore);
  }

  /// 초기 리더보드 목록 로드 (첫 페이지)
  Future<void> _onLoadRequested(
    LeaderboardLoadRequested event,
    Emitter<LeaderboardState> emit,
  ) async {
    emit(state.copyWith(isBusy: true, error: null));
    try {
      final entries = await repository.getLeaderboardEntries(
        keyword: state.keyword,
        page: 1,
        pageSize: _pageSize,
      );
      emit(state.copyWith(isBusy: false, entries: entries));
      log('Leaderboard loaded: $entries');
    } catch (e) {
      emit(state.copyWith(isBusy: false, error: e.toString()));
    }
  }

  /// 추가 페이지 로드 이벤트 핸들러 (페이징)
  Future<void> _onLoadMore(
    LoadMoreLeaderboard event,
    Emitter<LeaderboardState> emit,
  ) async {
    if (state.isBusy) return;
    // 현재 state의 currentPage 값을 사용하여 새로운 페이지 번호 계산
    int newPage = state.currentPage + 1;
    emit(state.copyWith(isBusy: true));
    try {
      final moreEntries = await repository.getLeaderboardEntries(
        keyword: state.keyword,
        page: newPage,
        pageSize: _pageSize,
      );
      final updatedEntries = List<LeaderboardEntry>.from(state.entries)
        ..addAll(moreEntries);
      emit(
        state.copyWith(
          isBusy: false,
          entries: updatedEntries,
          currentPage: newPage,
        ),
      );
      log('Loaded more entries: $moreEntries');
    } catch (e) {
      emit(state.copyWith(isBusy: false, error: e.toString()));
    }
  }

  /// 검색어 변경 이벤트 핸들러
  Future<void> _onSearchChanged(
    LeaderboardSearchChanged event,
    Emitter<LeaderboardState> emit,
  ) async {
    final newKeyword = event.keyword;
    if (newKeyword != state.keyword) {
      // 검색어 변경 시 페이징 리셋 (currentPage 1로) 및 데이터 재로드
      emit(state.copyWith(isBusy: true, keyword: newKeyword, currentPage: 1));
      try {
        final newEntries = await repository.getLeaderboardEntries(
          keyword: newKeyword,
          page: 1,
          pageSize: _pageSize,
        );
        emit(state.copyWith(isBusy: false, entries: newEntries));
        log('Leaderboard reloaded with keyword "$newKeyword": $newEntries');
      } catch (e) {
        emit(state.copyWith(isBusy: false, error: e.toString()));
      }
    }
  }
}



===== ./lib/view/leaderboard/leader_board_view_event.dart =====
part of 'leader_board_view_model.dart';

/// 리더보드 화면에서 발생하는 이벤트 정의
abstract class LeaderboardEvent extends Equatable {
  const LeaderboardEvent();

  @override
  List<Object?> get props => [];
}

/// 리더보드 목록을 로드하라는 이벤트 (초기 로드)
class LeaderboardLoadRequested extends LeaderboardEvent {
  const LeaderboardLoadRequested();
}

/// 검색어 변경 이벤트
class LeaderboardSearchChanged extends LeaderboardEvent {
  final String keyword;
  const LeaderboardSearchChanged(this.keyword);

  @override
  List<Object?> get props => [keyword];
}

/// 추가 페이지 로드를 요청하는 이벤트 (페이징)
class LoadMoreLeaderboard extends LeaderboardEvent {
  const LoadMoreLeaderboard();

  @override
  List<Object?> get props => [];
}



===== ./lib/view/leaderboard/leader_board_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/view/base_view.dart';
import 'package:tetris_app/view/leaderboard/leader_board_view_model.dart';

class LeaderboardView extends StatefulWidget {
  const LeaderboardView({super.key});

  @override
  State<LeaderboardView> createState() => _LeaderboardViewState();
}

class _LeaderboardViewState extends State<LeaderboardView> {
  late final LeaderboardViewModel viewModel;
  final ScrollController _scrollController = ScrollController();
  bool _searchEnabled = true; // 검색 기능 활성화 여부

  @override
  void initState() {
    super.initState();
    viewModel = LeaderboardViewModel(repository: context.read())
      ..add(const LeaderboardLoadRequested());
    _scrollController.addListener(_onScroll);
  }

  void _onScroll() {

    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 100 &&
        !viewModel.state.isBusy) {
      viewModel.add(const LoadMoreLeaderboard());
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    viewModel.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BaseView<LeaderboardViewModel>(
      viewModel: viewModel,
      builder: (context, viewModel) {
        final state = viewModel.state;
        return Scaffold(
          appBar: AppBar(
            title: const Text('전체 순위'),
            actions: [
              IconButton(
                icon: Icon(_searchEnabled ? Icons.search_off : Icons.search),
                onPressed: () {
                  setState(() {
                    _searchEnabled = !_searchEnabled;
                    if (!_searchEnabled) {
                      // 검색 기능 비활성화 시 전체 데이터를 다시 로드
                      viewModel.add(const LeaderboardLoadRequested());
                    }
                  });
                },
              ),
            ],
          ),
          body: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // 검색어 입력 필드: _searchEnabled에 따라 활성/비활성
                TextField(
                  enabled: _searchEnabled,
                  decoration: const InputDecoration(
                    labelText: '플레이어 이름 또는 ID로 검색',
                    hintText: '검색어를 입력하세요',
                    border: OutlineInputBorder(),
                  ),
                  onChanged: (text) {
                    viewModel.add(LeaderboardSearchChanged(text));
                  },
                ),
                const SizedBox(height: 8),
                // 에러 메시지
                if (state.error != null)
                  Text(
                    '오류 발생: ${state.error}',
                    style: const TextStyle(color: Colors.red),
                  ),
                const SizedBox(height: 8),
                // 리더보드 목록
                Expanded(
                  child:
                      state.isBusy && state.entries.isEmpty
                          ? const Center(child: CircularProgressIndicator())
                          : ListView.builder(
                            controller: _scrollController,
                            itemCount: state.entries.length + 1,
                            itemBuilder: (context, index) {
                              if (index < state.entries.length) {
                                final entry = state.entries[index];
                                return ListTile(
                                  leading: Text('${entry.rank}'),
                                  title: Text(entry.name),
                                  trailing: Text('점수: ${entry.score}'),
                                );
                              } else {
                                // 마지막 항목: 추가 데이터 로딩 중이면 로딩 인디케이터 표시
                                return state.isBusy
                                    ? const Padding(
                                      padding: EdgeInsets.all(8.0),
                                      child: Center(
                                        child: CircularProgressIndicator(),
                                      ),
                                    )
                                    : const SizedBox();
                              }
                            },
                          ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}



===== ./lib/view/game/game_view_model.dart =====
/// game_view_model.dart
/// BLoC 패턴을 구현하기 위한 ViewModel 클래스
/// BaseViewModel<GameViewEvent, GameViewState>를 상속받고,
/// 테트리스 게임 로직(이벤트 핸들러, 충돌 검사, 라인 제거 등)을 담당합니다.
///
/// [핵심 기능]
/// 1) 게임 초기화 및 시작 (GameInitialized)
/// 2) 정기적 자동 낙하 처리 (GameTicked)
/// 3) 사용자 입력에 따른 조각 이동 (PieceMoved)
/// 4) 조각 회전 처리 (PieceRotated)
/// 5) 충돌 검사, 라인 완성 검사, 점수 및 속도 업데이트
library;

import 'dart:async';
import 'dart:math';

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/models/tetrimino/direction.dart';
import 'package:tetris_app/models/tetrimino/piece_type.dart';
import 'package:tetris_app/models/tetrimino/position.dart';
import 'package:tetris_app/view/base_view_model.dart';
import 'package:tetris_app/view/game/game_view_event.dart';
import 'package:tetris_app/view/game/game_view_state.dart';

class GameViewModel extends BaseViewModel<GameViewEvent, GameViewState> {
  // 게임 보드의 폭과 높이 (10 x 20)
  static const int GRID_WIDTH = 10;
  static const int GRID_HEIGHT = 20;

  /// 타이머를 통해 주기적으로 GameTicked 이벤트를 발생시킵니다.
  Timer? _gameTimer;

  GameViewModel()
    : super(
        // 초기 상태 정의
        GameViewState(
          isBusy: false,
          grid: {},
          activePiecePosition: Position(0, 0),
          activePiecePositions: [],
          nextPieces: [],
        ),
      ) {
    // 이벤트 핸들러 등록
    on<GameInitialized>(_onGameInitialized);
    on<GameTicked>(_onGameTicked);
    on<PieceMoved>(_onPieceMoved);
    on<PieceRotated>(_onPieceRotated);
  }

  @override
  Future<void> close() {
    // ViewModel 해제 시 타이머도 취소
    _gameTimer?.cancel();
    return super.close();
  }

  /// [GameInitialized] 이벤트 처리 메서드
  /// 게임을 초기화하고, 새 조각 및 다음 조각들을 생성 후 타이머 시작
  void _onGameInitialized(GameInitialized event, Emitter<GameViewState> emit) {
    _gameTimer?.cancel();
    final random = Random();

    // 4개의 조각을 미리 생성하여, 첫 번째를 활성 조각으로 쓰고 나머지는 nextPieces에 저장
    final initialPieces = List.generate(
      4,
      (_) => PieceType.values[random.nextInt(PieceType.values.length)],
    );
    final initialPiece = initialPieces.first;
    final nextPieces = initialPieces.sublist(1);

    // 활성 조각을 보드의 최상단(또는 중앙) 부근에 두기 위한 위치
    // 이번 예시에선 y를 (GRID_HEIGHT)로 잡아 아래에서부터 쌓이듯 표현하거나,
    // 0으로 잡아 실제 테트리스와 동일한 상단 스폰 방식을 선택할 수 있음
    final initialPos = Position(GRID_WIDTH ~/ 2 - 1, 0);

    final piecePositions = _calculatePiecePositions(
      initialPiece,
      0,
      initialPos,
    );

    // 새로운 상태
    final newState = state.copyWith(
      isBusy: false,
      grid: {},
      activePiece: initialPiece,
      activePieceRotation: 0,
      activePiecePosition: initialPos,
      activePiecePositions: piecePositions,
      nextPieces: nextPieces,
      score: 0,
      level: 1,
      speed: 1.0,
      gameRunning: true,
      gameOver: false,
    );
    emit(newState);

    // 타이머 시작: speed에 따라 주기를 조정
    _gameTimer = Timer.periodic(
      Duration(milliseconds: (1000 / newState.speed).round()),
      (_) => add(const GameTicked()),
    );
  }

  /// [GameTicked] 이벤트 처리 메서드
  /// 일정 간격으로 호출되며, 조각을 1칸씩 자동 하강시킴
  /// 하단 충돌 시 조각을 고정하고 새 조각 생성, 라인 제거 등 처리
  void _onGameTicked(GameTicked event, Emitter<GameViewState> emit) {
    if (!state.gameRunning || state.gameOver) return;

    final currentPos = state.activePiecePosition;
    // y를 1 증가시켜 한 칸 '아래'로 이동
    final newPos = Position(currentPos.x, currentPos.y + 1);

    // 현재 활성 블록 조각들의 위치를 로그로 출력
    print("블록 조각들의 현재 위치:");
    for (final pos in state.activePiecePositions) {
      print(" - x=${pos.x}, y=${pos.y}");
    }

    if (_canMoveTo(state.activePiece!, state.activePieceRotation, newPos)) {
      final newPositions = _calculatePiecePositions(
        state.activePiece!,
        state.activePieceRotation,
        newPos,
      );
      // 정상 이동 가능
      emit(
        state.copyWith(
          activePiecePosition: newPos,
          activePiecePositions: newPositions,
        ),
      );
    } else {
      // 충돌 발생 => 현재 조각을 grid에 고정
      final newGrid = Map<String, bool>.from(state.grid);
      bool gameOver = false; // 새 변수를 선언해두고

      for (final pos in state.activePiecePositions) {
        newGrid['${pos.x},${pos.y}'] = true;
        // y=0인 칸이 하나라도 있다면 게임 오버
        if (pos.y == 0) {
          gameOver = true;
        }
      }

      // 라인 제거
      int linesCleared = _clearFullRows(newGrid);
      // 한 줄 제거당 100점
      int additionalScore = 100 * linesCleared;
      // 누적 100점마다 속도 0.1 증가
      final totalScore = state.score + additionalScore;
      // 고정 후 새 조각 스폰
      final random = Random();
      final nextPiece = state.nextPieces.first;
      final nextPieces = List<PieceType>.from(state.nextPieces.sublist(1))
        ..add(PieceType.values[random.nextInt(PieceType.values.length)]);
      final spawnPos = Position(GRID_WIDTH ~/ 2 - 1, 0);
      final spawnPositions = _calculatePiecePositions(nextPiece, 0, spawnPos);

      // 게임 오버 검사: 새 조각 위치가 이미 차있으면 게임 오버
      for (final pos in spawnPositions) {
        if (newGrid.containsKey('${pos.x},${pos.y}')) {
          gameOver = true;
          break;
        }
      }

      // 속도 업데이트: (score / 100) * 0.1 => 예: 100점마다 0.1 증가
      double newSpeed = 1.0 + (totalScore ~/ 100) * 0.1;

      final newState = state.copyWith(
        grid: newGrid,
        activePiece: nextPiece,
        activePieceRotation: 0,
        activePiecePosition: spawnPos,
        activePiecePositions: spawnPositions,
        nextPieces: nextPieces,
        score: totalScore,
        speed: newSpeed,
        gameRunning: !gameOver,
        gameOver: gameOver,
      );
      emit(newState);

      // 충돌 후 타이머 리셋
      _gameTimer?.cancel();
      if (!gameOver) {
        _gameTimer = Timer.periodic(
          Duration(milliseconds: (1000 / newState.speed).round()),
          (_) => add(const GameTicked()),
        );
      }
    }
  }

  /// [PieceMoved] 이벤트 처리 메서드
  /// 사용자 입력에 따라 조각을 왼쪽, 오른쪽, 아래로 이동
  void _onPieceMoved(PieceMoved event, Emitter<GameViewState> emit) {
    if (!state.gameRunning || state.gameOver) return;
    final pos = state.activePiecePosition;
    Position newPos;
    switch (event.direction) {
      case Direction.left:
        newPos = Position(pos.x - 1, pos.y);
        break;
      case Direction.right:
        newPos = Position(pos.x + 1, pos.y);
        break;
      case Direction.down:
        newPos = Position(pos.x, pos.y + 1);
        break;
    }
    if (_canMoveTo(state.activePiece!, state.activePieceRotation, newPos)) {
      final newPositions = _calculatePiecePositions(
        state.activePiece!,
        state.activePieceRotation,
        newPos,
      );
      emit(
        state.copyWith(
          activePiecePosition: newPos,
          activePiecePositions: newPositions,
        ),
      );
    }
  }

  /// [PieceRotated] 이벤트 처리 메서드
  /// 조각 회전 (activePieceRotation + 1) % 4 => 새 회전 상태
  void _onPieceRotated(PieceRotated event, Emitter<GameViewState> emit) {
    if (!state.gameRunning || state.gameOver) return;
    final newRotation = (state.activePieceRotation + 1) % 4;
    if (_canMoveTo(
      state.activePiece!,
      newRotation,
      state.activePiecePosition,
    )) {
      final newPositions = _calculatePiecePositions(
        state.activePiece!,
        newRotation,
        state.activePiecePosition,
      );
      emit(
        state.copyWith(
          activePieceRotation: newRotation,
          activePiecePositions: newPositions,
        ),
      );
    }
  }

  /// 조각이 특정 위치와 회전 상태로 이동 가능한지 검사
  bool _canMoveTo(PieceType pieceType, int rotation, Position pos) {
    final positions = _calculatePiecePositions(pieceType, rotation, pos);
    for (final p in positions) {
      // 보드 범위를 벗어나면 이동 불가
      // y <= 0 이 아닌 y < 0 으로 수정
      if (p.x < 0 || p.x >= GRID_WIDTH || p.y < 0 || p.y >= GRID_HEIGHT) {
        return false;
      }
      // 이미 고정된 블록과 겹치면 이동 불가
      if (state.grid.containsKey('${p.x},${p.y}')) {
        return false;
      }
    }
    return true;
  }

  /// 조각의 shape(상대 좌표)에 따라 실제 보드 좌표를 계산
  List<Position> _calculatePiecePositions(
    PieceType pieceType,
    int rotation,
    Position pos,
  ) {
    // shape 가져오기 (PieceType에 따라 정의된 상대 좌표, rotation별 변환 등)
    final shape = getTetriminoShape(pieceType, rotation);

    return shape.map((offset) {
      return Position(pos.x + offset.x, pos.y + offset.y);
    }).toList();
  }

  /// 그리드에서 가득 찬 행을 찾아 제거하고, 제거된 행의 개수를 반환
  int _clearFullRows(Map<String, bool> grid) {
    int clearedRows = 0; // <- 여기서 변수를 선언해줍니다.

    // 아래에서 위로 확인 (top=0, bottom=GRID_HEIGHT-1)
    for (int y = GRID_HEIGHT - 1; y >= 0; y--) {
      bool full = true;
      for (int x = 0; x < GRID_WIDTH; x++) {
        if (!grid.containsKey('$x,$y')) {
          full = false;
          break;
        }
      }
      if (full) {
        clearedRows++;
        // 해당 행 제거
        for (int x = 0; x < GRID_WIDTH; x++) {
          grid.remove('$x,$y');
        }
        // 위쪽 블록들을 아래로 이동
        for (int yy = y - 1; yy >= 0; yy--) {
          for (int x = 0; x < GRID_WIDTH; x++) {
            if (grid.remove('$x,$yy') == true) {
              grid['$x,${yy + 1}'] = true;
            }
          }
        }
        // 제거한 후 같은 행을 다시 검사하기 위해
        // y 위치를 1 증가시켜서 직전 반복을 다시 확인
        y++;
      }
    }
    return clearedRows;
  }
}

/// 
/// 아래 예시 shape 데이터나 getTetriminoShape 함수는
/// piece.dart 또는 별도 헬퍼에 구현할 수 있습니다.
/// 예: rotation별로 블록의 상대 좌표를 정의.
/// 
/// List<Position> getTetriminoShape(PieceType pieceType, int rotation) { ... }
///


===== ./lib/view/game/game_view_state.dart =====
/// game_view_state.dart
/// 게임 화면의 상태를 표현하는 클래스입니다.
/// BaseViewState를 상속받고 EquatableMixin을 사용하여
/// 상태 비교 및 관리가 용이하도록 구성합니다.
///
/// - grid: 고정된 블록들의 위치를 저장하는 해시맵 (key: "x,y", value: bool)
/// - activePiece: 현재 떨어지고 있는 조각의 종류 (PieceType)
/// - activePieceRotation: 현재 조각의 회전 상태 (0~3)
/// - activePiecePosition: 보드 내에서 조각의 기준 위치
/// - activePiecePositions: 조각을 구성하는 블록들의 실제 좌표
/// - nextPieces: 다음에 떨어질 조각들을 미리 생성하여 큐 형태로 관리
/// - score: 점수
/// - level: 게임 레벨 (기본 1, 점수에 따라 자동 증가)
/// - speed: 하강 속도 (기본 1.0, 누적 100점마다 0.1씩 증가)
/// - gameRunning: 게임 진행 여부
/// - gameOver: 게임 오버 여부
library;

import 'package:equatable/equatable.dart';
import 'package:tetris_app/models/tetrimino/piece_type.dart';
import 'package:tetris_app/models/tetrimino/position.dart';
import 'package:tetris_app/view/base_view_state.dart';

class GameViewState extends BaseViewState with EquatableMixin {
  /// 고정된 블록이 있는 위치를 저장합니다.
  /// key: "x,y" 문자열, value: 블록 존재 여부
  final Map<String, bool> grid;

  /// 현재 활성 조각 (I, O, T, S, Z, J, L 등)
  final PieceType? activePiece;

  /// 조각의 회전 상태 (0~3)
  final int activePieceRotation;

  /// 조각의 기준 위치 (상단 좌표)
  final Position activePiecePosition;

  /// 현재 활성 조각을 구성하는 모든 블록의 좌표
  final List<Position> activePiecePositions;

  /// 다음에 떨어질 조각들의 목록
  final List<PieceType> nextPieces;

  /// 플레이어의 점수
  final int score;

  /// 게임 레벨 (누적 점수 100점마다 1 증가)
  final int level;

  /// 블록 하강 속도 (1.0에서 시작, 0.1씩 증가)
  final double speed;

  /// 게임 진행 여부
  final bool gameRunning;

  /// 게임 오버 여부
  final bool gameOver;

  const GameViewState({
    required super.isBusy,
    required this.grid,
    this.activePiece,
    this.activePieceRotation = 0,
    required this.activePiecePosition,
    required this.activePiecePositions,
    required this.nextPieces,
    this.score = 0,
    this.level = 1,
    this.speed = 1.0,
    this.gameRunning = false,
    this.gameOver = false,
  });

  /// copyWith 메서드를 통해 특정 필드만 변경하여 새 상태를 만들 수 있습니다.
  GameViewState copyWith({
    Map<String, bool>? grid,
    PieceType? activePiece,
    int? activePieceRotation,
    Position? activePiecePosition,
    List<Position>? activePiecePositions,
    List<PieceType>? nextPieces,
    int? score,
    int? level,
    double? speed,
    bool? gameRunning,
    bool? gameOver,
    bool? isBusy,
  }) {
    return GameViewState(
      isBusy: isBusy ?? this.isBusy,
      grid: grid ?? this.grid,
      activePiece: activePiece ?? this.activePiece,
      activePieceRotation: activePieceRotation ?? this.activePieceRotation,
      activePiecePosition: activePiecePosition ?? this.activePiecePosition,
      activePiecePositions: activePiecePositions ?? this.activePiecePositions,
      nextPieces: nextPieces ?? this.nextPieces,
      score: score ?? this.score,
      level: level ?? this.level,
      speed: speed ?? this.speed,
      gameRunning: gameRunning ?? this.gameRunning,
      gameOver: gameOver ?? this.gameOver,
    );
  }

  @override
  List<Object?> get props => [
    grid,
    activePiece,
    activePieceRotation,
    activePiecePosition,
    activePiecePositions,
    nextPieces,
    score,
    level,
    speed,
    gameRunning,
    gameOver,
    isBusy,
  ];
}



===== ./lib/view/game/game_view.dart =====
// game_view.dart
// 게임 UI를 담당하는 StatefulWidget 클래스입니다.
// 게임 보드, 점수/레벨 표시 및 블록 조작 버튼들을 배치하며,
// 시작 버튼 없이 화면 빌드 완료 후 자동으로 게임을 시작하고,
// 게임 오버 발생 시 일정 시간 후 자동으로 재시작합니다.
import 'package:flutter/material.dart';
import 'package:tetris_app/models/tetrimino/direction.dart';
import 'package:tetris_app/models/tetrimino/piece_type.dart';
import 'package:tetris_app/utils/route_path.dart';
import 'package:tetris_app/view/base_view.dart';
import 'package:tetris_app/view/game/game_view_event.dart';
import 'package:tetris_app/view/game/game_view_model.dart';
import 'package:tetris_app/view/game/game_view_state.dart';

class GameView extends StatefulWidget {
  const GameView({super.key});

  @override
  State<GameView> createState() => _GameViewState();
}

class _GameViewState extends State<GameView> {
  late final GameViewModel gameViewModel;


  @override
  void initState() {
    super.initState();
    // ViewModel 인스턴스 생성
    gameViewModel = GameViewModel();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      gameViewModel.add(GameInitialized());
    });
  }

  @override
  void dispose() {
    // 화면 종료 시 타이머 정리
    gameViewModel.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // BaseView를 사용하여 ViewModel의 상태 변화를 구독하고 UI를 빌드합니다.
    return BaseView(
      viewModel: gameViewModel,
      builder: (context, viewModel) {
        // 여기서 gameOver 상태를 감지하여 네비게이트
        if (viewModel.state.gameOver) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            // 이미 game over라면 네비게이션
            Navigator.pushNamed(
              context,
              RoutePath.gameOver,
              arguments: viewModel.state.score,
            );
          });
        }
        return Scaffold(
          appBar: AppBar(title: const Text('Tetris Game')),
          body: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // 상단에 점수와 레벨 표시
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '점수: ${viewModel.state.score}',
                      style: const TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      '레벨: ${viewModel.state.level}',
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                // 게임 오버 메시지 표시 (게임 오버 시)
                if (viewModel.state.gameOver)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.7),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Text(
                      '게임 오버!',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                const SizedBox(height: 8),
                // 게임 보드 영역 (GridView를 이용해 그리드 렌더링)
                Expanded(
                  child: Center(
                    child: AspectRatio(
                      aspectRatio:
                          GameViewModel.GRID_WIDTH / GameViewModel.GRID_HEIGHT,
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.grey[300],
                          border: Border.all(color: Colors.black, width: 2),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: _buildGameBoard(viewModel.state),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                // 하단에 블록 조작 버튼들 배치
                _buildControls(viewModel, viewModel.state),
              ],
            ),
          ),
        );
      },
    );
  }

  // GridView를 생성하여 게임 보드를 그립니다.
  Widget _buildGameBoard(GameViewState state) {
    return GridView.builder(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: GameViewModel.GRID_WIDTH, // 열 개수는 게임 보드의 너비로 설정
      ),
      itemCount: GameViewModel.GRID_WIDTH * GameViewModel.GRID_HEIGHT,
      physics: const NeverScrollableScrollPhysics(), // 사용자가 직접 스크롤 불가
      padding: EdgeInsets.zero,
      itemBuilder: (context, index) {
        // 1차원 index를 2차원 (x, y) 좌표로 변환
        final x = index % GameViewModel.GRID_WIDTH; // 열
        final y = index ~/ GameViewModel.GRID_WIDTH; // 행
        // 셀의 기본 배경색 (빈 공간)
        Color cellColor = Colors.grey[200]!;
        final key = '$x,$y';
        // 고정된 블록이 있는 위치인지 확인
        if (state.grid.containsKey(key)) {
          cellColor = Colors.blueGrey; // 고정된 블록은 어두운 색으로 표시
        }
        // 현재 떨어지고 있는 활성 블록의 위치인지 확인
        for (final pos in state.activePiecePositions) {
          if (pos.x == x && pos.y == y) {
            // 활성 조각의 셀인 경우 색상을 다르게 지정 (조각 종류별로 구분 가능)
            switch (state.activePiece) {
              case PieceType.I:
                cellColor = Colors.cyan;
                break;
              case PieceType.J:
                cellColor = Colors.blue;
                break;
              case PieceType.L:
                cellColor = Colors.orange;
                break;
              case PieceType.O:
                cellColor = Colors.yellow;
                break;
              case PieceType.S:
                cellColor = Colors.green;
                break;
              case PieceType.T:
                cellColor = Colors.purple;
                break;
              case PieceType.Z:
                cellColor = Colors.red;
                break;
              default:
                cellColor = Colors.purple;
            }
            break;
          }
        }
        return Container(
          margin: const EdgeInsets.all(1),
          decoration: BoxDecoration(
            color: cellColor,
            borderRadius: BorderRadius.circular(2),
          ),
        );
      },
    );
  }

  // 좌/우/회전/하강 컨트롤 버튼 위젯들을 생성합니다.
  Widget _buildControls(GameViewModel viewModel, GameViewState state) {
    return Column(
      children: [
        // 좌, 회전, 우 버튼을 한 행에 배치
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _buildControlButton(
              icon: Icons.arrow_left,
              onPressed:
                  state.gameRunning && !state.gameOver
                      ? () => viewModel.add(PieceMoved(Direction.left))
                      : null,
            ),
            const SizedBox(width: 16),
            _buildControlButton(
              icon: Icons.rotate_right,
              onPressed:
                  state.gameRunning && !state.gameOver
                      ? () => viewModel.add(PieceRotated())
                      : null,
            ),
            const SizedBox(width: 16),
            _buildControlButton(
              icon: Icons.arrow_right,
              onPressed:
                  state.gameRunning && !state.gameOver
                      ? () => viewModel.add(PieceMoved(Direction.right))
                      : null,
            ),
          ],
        ),
        const SizedBox(height: 12),
        // 아래로 내리는 버튼은 별도로 배치
        _buildControlButton(
          icon: Icons.arrow_downward,
          onPressed:
              state.gameRunning && !state.gameOver
                  ? () => viewModel.add(PieceMoved(Direction.down))
                  : null,
          size: 60, // 아래 버튼은 약간 크게
        ),
      ],
    );
  }

  // 조작용 원형 아이콘 버튼 생성 헬퍼 위젯
  Widget _buildControlButton({
    required IconData icon,
    required VoidCallback? onPressed,
    double size = 48,
  }) {
    return Material(
      color: onPressed == null ? Colors.grey : Colors.blue,
      shape: CircleBorder(),
      child: InkWell(
        onTap: onPressed,
        customBorder: CircleBorder(),
        child: SizedBox(
          width: size,
          height: size,
          child: Icon(icon, color: Colors.white, size: size * 0.5),
        ),
      ),
    );
  }
}



===== ./lib/view/game/game_view_event.dart =====
/// game_view_event.dart
/// 게임 진행 중 발생하는 이벤트들을 정의합니다.
/// Bloc/ViewModel에서 해당 이벤트를 받아 처리함.
///
/// - GameInitialized: 게임 시작 및 초기화
/// - GameTicked: 일정 주기로 자동 낙하(타이머 이벤트)
/// - PieceMoved: 플레이어가 지정한 방향(왼쪽, 오른쪽, 아래쪽)으로 이동
/// - PieceRotated: 조각을 90도 회전
library;

import 'package:equatable/equatable.dart';
import 'package:tetris_app/models/tetrimino/direction.dart';

abstract class GameViewEvent extends Equatable {
  const GameViewEvent();

  @override
  List<Object?> get props => [];
}

/// 게임을 초기화하고, 첫 번째 조각을 생성하여 낙하를 시작하는 이벤트
class GameInitialized extends GameViewEvent {
  const GameInitialized();
}

/// 게임 틱 (정기적 업데이트) 이벤트
/// 일정 간격마다 발생하여, 조각이 자동으로 1칸씩 하강하도록 함
class GameTicked extends GameViewEvent {
  const GameTicked();
}

/// 사용자가 좌/우/하 이동을 입력했을 때 발생
/// Direction 파라미터(left, right, down)를 활용
class PieceMoved extends GameViewEvent {
  final Direction direction;
  const PieceMoved(this.direction);

  @override
  List<Object?> get props => [direction];
}

/// 사용자가 조각 회전을 입력했을 때 발생
class PieceRotated extends GameViewEvent {
  const PieceRotated();
}



===== ./lib/view/base_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/theme/component/circular_indicator.dart';
import 'package:tetris_app/view/base_view_model.dart';

class BaseView<T extends BaseViewModel> extends StatelessWidget {
  const BaseView({
    super.key,
    required this.viewModel,
    required this.builder,
  });

  final T viewModel;
  final Widget Function(BuildContext context, T viewModel) builder;

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => viewModel,
      child: Builder(
        builder: (context) {
          final viewModel = context.watch<T>();
          return CircularIndicator(
            isBusy: viewModel.state.isBusy,
            child: builder(context, viewModel),
          );
        },
      ),
    );
  }
}



===== ./lib/view/game_over/game_over_view_model.dart =====
import 'dart:developer';

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/models/score.dart';
import 'package:tetris_app/repositories/score_repository.dart';
import 'package:tetris_app/view/base_view_model.dart';
import 'package:tetris_app/view/game_over/game_over_view_event.dart';
import 'package:tetris_app/view/game_over/game_over_view_state.dart';

class GameOverViewModel
    extends BaseViewModel<GameOverEvent, GameOverViewState> {
  final ScoreRepository scoreRepo;
  // 필요시 UserRepository를 추가하여 사용자 ID를 가져올 수 있음

  GameOverViewModel({required this.scoreRepo})
    : super(GameOverViewState.initial()) {
    on<GameOverInitialized>(_onGameOverInitialized);
  }

  /// 게임 오버 이벤트 처리 메서드
  /// - isBusy를 true로 설정하여 로딩 상태를 표시합니다.
  /// - 현재 점수와 현재 시각을 로컬 DB에 저장하고,
  /// - 'http://localhost:2222/scores' 엔드포인트로 POST 전송합니다.
  /// - 작업 완료 후 isBusy를 false로 되돌리고, 최종 점수를 상태에 반영합니다.
  Future<void> _onGameOverInitialized(
    GameOverInitialized event,
    Emitter<GameOverViewState> emit,
  ) async {
    // 로딩 시작: 화면에 로딩 인디케이터 표시
    emit(state.copyWith(isBusy: true));

    final scoreValue = event.lastScore;

    try {
      // 1) 로컬 DB에 점수 저장 (ScoreRepository 사용)
      final now = DateTime.now();
      final scoreObj = Score(score: scoreValue, dateTime: now);
      await scoreRepo.addScore(scoreObj);

      // // 2) 서버에 POST 전송
      // // 여기서는 예시로 사용자 ID를 'player1'로 하드코딩
      // final userId = 'player1';
      // final response = await NetHelper.postJson(
      //   url: 'http://localhost:2222/scores',
      //   body: {'id': userId, 'score': scoreValue},
      // );

      // if (response != null) {
      //   log('POST 성공: $response');
      // } else {
      //   log('POST 실패');
      // }

      // 3) 최종 점수를 상태에 반영하고, 로딩 종료
      emit(state.copyWith(finalScore: scoreValue, isBusy: false));
    } catch (e) {
      log('오류 발생: $e');
      emit(state.copyWith(finalScore: scoreValue, isBusy: false));
    }
  }
}



===== ./lib/view/game_over/game_over_view_state.dart =====
import 'package:equatable/equatable.dart';
import 'package:tetris_app/view/base_view_state.dart';

class GameOverViewState extends BaseViewState with EquatableMixin {
  final int finalScore;

  const GameOverViewState({required super.isBusy, required this.finalScore});

  factory GameOverViewState.initial() {
    // 초기 상태: isBusy=false, score=0
    return const GameOverViewState(isBusy: false, finalScore: 0);
  }

  GameOverViewState copyWith({bool? isBusy, int? finalScore}) {
    return GameOverViewState(
      isBusy: isBusy ?? this.isBusy,
      finalScore: finalScore ?? this.finalScore,
    );
  }

  @override
  List<Object> get props => [isBusy, finalScore];
}



===== ./lib/view/game_over/game_over_view.dart =====
// game_over_view.dart
// 게임 오버 화면을 담당하는 StatelessWidget입니다.
// GameOverViewModel을 BaseView를 통해 주입받아,
// 로컬 DB 저장 및 서버 POST 작업 후 최종 점수를 표시하고,
// "홈으로 돌아가기" 버튼을 통해 메인 화면으로 이동할 수 있도록 구성합니다.

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/utils/route_path.dart';
import 'package:tetris_app/view/base_view.dart';
import 'package:tetris_app/view/game_over/game_over_view_event.dart';
import 'package:tetris_app/view/game_over/game_over_view_model.dart';

class GameOverView extends StatelessWidget {
  final int lastScore;

  const GameOverView({super.key, required this.lastScore});

  @override
  Widget build(BuildContext context) {
    // BaseView를 통해 GameOverViewModel을 주입하고, 초기 이벤트로 마지막 점수를 전달합니다.
    return BaseView<GameOverViewModel>(
      viewModel: GameOverViewModel(scoreRepo: context.read())
        ..add(GameOverInitialized(lastScore)),
      builder: (context, viewModel) {
        final state = viewModel.state;
        return Scaffold(
          appBar: AppBar(title: const Text('Game Over')),
          body: Padding(
            padding: const EdgeInsets.all(16.0),
            child:
                state.isBusy
                    ? const Center(child: CircularProgressIndicator())
                    : Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          '최종 점수: ${state.finalScore}',
                          style: const TextStyle(
                            fontSize: 28,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 24),
                        ElevatedButton(
                          onPressed: () {
                            // 홈 화면으로 돌아갑니다.
                            Navigator.pushNamedAndRemoveUntil(
                              context,
                              RoutePath.home,
                              (route) => false,
                            );
                          },
                          child: const Text(
                            '홈으로 돌아가기',
                            style: TextStyle(fontSize: 18),
                          ),
                        ),
                      ],
                    ),
          ),
        );
      },
    );
  }
}



===== ./lib/view/game_over/game_over_view_event.dart =====
import 'package:equatable/equatable.dart';

abstract class GameOverEvent extends Equatable {
  const GameOverEvent();

  @override
  List<Object?> get props => [];
}

// 게임 오버 화면이 열릴 때, 마지막 점수를 전달하기 위한 이벤트
class GameOverInitialized extends GameOverEvent {
  final int lastScore;
  const GameOverInitialized(this.lastScore);

  @override
  List<Object?> get props => [lastScore];
}


===== ./lib/view/login/login_view_model.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/repositories/user_repository.dart';
import 'package:tetris_app/view/base_view_model.dart';

import 'login_view_event.dart';
import 'login_view_state.dart';

class LoginViewModel extends BaseViewModel<LoginViewEvent, LoginViewState> {
  final UserRepository userRepository;

  LoginViewModel({required this.userRepository})
      : super(LoginViewState(isBusy: false)) {
    // 이벤트 핸들러 등록
    on<UserIdChanged>(_onUserIdChanged);
    on<LoginButtonPressed>(_onLoginButtonPressed);
    _checkPersistedUser();
  }

  Future<void> _onUserIdChanged(
      UserIdChanged event, Emitter<LoginViewState> emit) async {
    emit(state.copyWith(userId: event.userId, error: null));
  }

  Future<void> _onLoginButtonPressed(
      LoginButtonPressed event, Emitter<LoginViewState> emit) async {
    if (state.userId.trim().isEmpty) {
      emit(state.copyWith(error: 'User ID cannot be empty'));
      return;
    }
    emit(state.copyWith(isLoading: true, error: null));

    await Future.delayed(const Duration(seconds: 1));
    await userRepository.saveUserId(state.userId);

    emit(state.copyWith(isLoading: false, isSuccess: true));
  }

  Future<void> _checkPersistedUser() async {
    final storedUserId = await userRepository.loadUserId();
    if (storedUserId != null && storedUserId.trim().isNotEmpty) {
      add(UserIdChanged(storedUserId));
      add(LoginButtonPressed());
    }
  }
}


===== ./lib/view/login/login_view_state.dart =====
import 'package:equatable/equatable.dart';
import 'package:tetris_app/view/base_view_state.dart';

/// 로그인 화면의 상태를 관리하는 모델 클래스이다.
/// BaseViewState를 상속받고 EquatableMixin을 사용하여 값 비교를 용이하게 구현하였사있다.
class LoginViewState extends BaseViewState with EquatableMixin {
  /// 사용자가 입력한 ID
  final String userId;
  /// 로딩 중인지 여부
  final bool isLoading;
  /// 로그인 성공 여부
  final bool isSuccess;
  /// 에러 메시지 (있을 경우)
  final String? error;

  const LoginViewState({
    this.userId = '',
    this.isLoading = false,
    this.isSuccess = false,
    this.error,
    required super.isBusy,
  });

  /// 상태 변경 시 불변성을 유지하며 새로운 상태를 생성하기 위한 메서드
  LoginViewState copyWith({
    String? userId,
    bool? isLoading,
    bool? isSuccess,
    String? error,
    bool? isBusy,
  }) {
    return LoginViewState(
      userId: userId ?? this.userId,
      isLoading: isLoading ?? this.isLoading,
      isSuccess: isSuccess ?? this.isSuccess,
      error: error,
      isBusy: isBusy ?? this.isBusy,
    );
  }

  @override
  List<Object?> get props => [userId, isLoading, isSuccess, error, isBusy];
}


===== ./lib/view/login/login_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/utils/route_path.dart';
import 'package:tetris_app/view/base_view.dart';
import 'package:tetris_app/view/login/login_view_event.dart';
import 'package:tetris_app/view/login/login_view_model.dart';
import 'package:tetris_app/view/login/login_view_state.dart';

class LoginView extends StatelessWidget {
  const LoginView({super.key});

  @override
  Widget build(BuildContext context) {
    return BaseView<LoginViewModel>(
      viewModel: LoginViewModel(
        userRepository: context.read(),
      ),
      builder: (context, viewModel) {
        final state = viewModel.state;
        if (state.isSuccess) {
          // 로그인 성공 상태이면, 빌드 완료 후 홈 화면으로 전환
          WidgetsBinding.instance.addPostFrameCallback((_) {
            Navigator.pushReplacementNamed(context, RoutePath.home);
          });
          // 네비게이션이 완료될 때까지 빈 위젯 반환
          return const SizedBox.shrink();
        }
        return Scaffold(
          appBar: AppBar(
            title: Text('Login'), // 로컬라이징된 로그인 텍스트 사용
          ),
          body: Padding(
            padding: const EdgeInsets.all(16.0),
            child: state.isSuccess
                ? _buildSuccess(state)
                : _buildLogin(context, viewModel, state),
          ),
        );
      },
    );
  }

  Widget _buildLogin(
      BuildContext context, LoginViewModel viewModel, LoginViewState state) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const Text(
          '아이디를 입력해주세요',
          style: TextStyle(fontSize: 18),
        ),
        const SizedBox(height: 16),
        TextField(
          onChanged: (value) => viewModel.add(UserIdChanged(value)),
          decoration: InputDecoration(
            labelText: 'User ID',
            border: const OutlineInputBorder(),
            errorText: state.error,
          ),
        ),
        const SizedBox(height: 16),
        state.isLoading
            ? const CircularProgressIndicator()
            : ElevatedButton(
                onPressed: () => viewModel.add(LoginButtonPressed()),
                child: const Text('로그인'),
              ),
      ],
    );
  }

  Widget _buildSuccess(LoginViewState state) {
    return Center(
      child: Text(
        '환영합니다, ${state.userId}님!',
        style: const TextStyle(fontSize: 20),
      ),
    );
  }
}



===== ./lib/view/login/login_view_event.dart =====
/// 로그인 화면에서 발생할 수 있는 이벤트들을 정의합니다.
abstract class LoginViewEvent {}

/// 사용자가 ID 입력란의 값을 변경할 때 발생하는 이벤트
class UserIdChanged extends LoginViewEvent {
  final String userId;
  UserIdChanged(this.userId);
}

/// 사용자가 로그인 버튼을 누를 때 발생하는 이벤트
class LoginButtonPressed extends LoginViewEvent {}


===== ./lib/service/theme/theme_event.dart =====
part of 'theme_service.dart';

abstract class ThemeServiceEvent {}

// ignore: camel_case_types
class onToggleTheme extends ThemeServiceEvent {}




===== ./lib/service/theme/theme_service.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:tetris_app/theme/dark_theme.dart';
import 'package:tetris_app/theme/foundation/app_theme.dart';
import 'package:tetris_app/theme/foundation/app_typo.dart';
import 'package:tetris_app/theme/light_theme.dart';

part 'theme_event.dart';

class ThemeService extends Bloc<ThemeServiceEvent, AppTheme> {
  ThemeService({
    AppTheme? theme,
  }) : super(theme ?? LightTetrisTheme()) {
    on<onToggleTheme>((event, emit) {
      emit(state.brightness == Brightness.light ? DarkTetrisTheme() : LightTetrisTheme());
    });
  }

  ThemeData get themeData {
    return ThemeData(
      // scaffold 위젯의 배경색을 지정하는 theme Data의 속성
        scaffoldBackgroundColor: state.color.surface,
        appBarTheme: AppBarTheme(
          // 앱바 백그라운드 컬러 테마에 따라 변경
            backgroundColor: state.color.surface,
            // 앱바 그림자를 0으로 설정하여 평평 하게 만든다
            elevation: 0,
            // 앱바 타이틀을 중앙 정렬하지 않고 기본정렬을 사용하게 만든다
            centerTitle: false,
            iconTheme: IconThemeData(
              color: state.color.text,
            ),
            titleTextStyle:
            state.typo.headline2.copyWith(color: state.color.text)),
        );
  }
}

extension ThemeServiceExt on BuildContext {
  ThemeService get themeService => watch<ThemeService>();
  AppTheme get theme => themeService.state;
  AppColor get color => theme.color;
  AppDeco get deco => theme.deco;
  AppTypo get typo => theme.typo;
}





===== ./.dart_tool/flutter_build/dart_plugin_registrant.dart =====
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.7

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite_android/sqflite_android.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteAndroid.registerWith();
      } catch (err) {
        print(
          '`sqflite_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}



===== ./.dart_tool/dartpad/web_plugin_registrant.dart =====
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:audioplayers_web/audioplayers_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  AudioplayersPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}



